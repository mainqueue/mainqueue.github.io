---
title: KeyPath и где они обитают. Часть 1.
layout: page
excerpt_separator: <!--more-->
---
`KeyPath` - весьма интересный механизм `Swift`. Сегодня мы начнем смотреть как он работает на примере простейших структур.
<!--more-->
## Извлекаем значение поля

Рассмотрим следующую структуру:

```swift
struct Pair {
    let first: Int
    let second: Int
}
```

Многие читатели наверняка уже знакомы с концепцией `KeyPath`. Каждый экземпляр класса `KeyPath` описывает всю необходимую информацию для того, чтобы в рантайме извлечь некоторое значения у экземпляра некоторого типа. Для описания `KeyPath` чаще всего используют выражения типа `\Pair.first`, которые во время компиляции заменяются на экземпляры класса `KeyPath<Pair, Int>`. Таким образом, используя соответствующий *keypath*, мы могли бы извлечь значение поля `first` у экземпляра `Pair`:

```swift
let pair = Pair(first: 1, second: 2)
let first = pair[keyPath: \Pair.first] // 1
```

У читателя может возникнуть вопрос, а зачем вообще в предложенном примере извлекать значение поля `first`, используя *keypath*, почему бы напрямую не обратиться к `pair`, и извлечь нужное нам значение?

```swift
let pair = Pair(first: 1, second: 2)
let first = pair.first // 1
```

Действительно, можно просто напрямую извлечь значение нужного поля. При этом получим абсолютно такой же результат. А есть ли тогда какая-то существенная разница в написанном коде? Давайте скомпилируем оба варианта кода и опустимся на уровень SIL.

```swift
swiftc -emit-sil -O keypath.swift

// keypath.swift
struct Pair {
    let first: Int
    let second: Int
}

let pair = Pair(first: 1, second: 2)
let first_keypath = pair[keyPath: \Pair.first]
let first = pair.first

// sil для first_keypath
%0 = integer_literal $Builtin.Int64, 1          
%1 = struct $Int (%0 : $Builtin.Int64)          

// sil для first
%0 = integer_literal $Builtin.Int64, 1          
%1 = struct $Int (%0 : $Builtin.Int64)          
```

Получился интересный результат. Несмотря на то, что исходный код для `first_keypath` и `first` существенно отличается, компилятор же транслирует его в абсолютно одинаковый *sil*-код. Это первая важная особенность *keypath*, которую мы обнаружили. Если во время компиляции есть возможность определить лейаут объекта, по отношению к которому применяется *keypath*, а также при должных включенных оптимизациях, то компилятор способен эволюционировать код аналогично тому, который сгенерировался бы при обычном обращении к полю напрямую, без использования *keypath*.

## Динамическая природа

Давайте рассмотрим другой пример, в котором компилятор может быть не способен применить ранее описанные оптимизации. Опишем функцию, которая позволит извлекать информацию о пользователе (модель `UserInfo`) из любого произвольного источника `T`:

```swift
struct UserInfo {
    let age: Int
}

func getUserInfo<T>(
    from source: T,
    at keypath: KeyPath<T, UserInfo>
) -> UserInfo {
    source[keyPath: keypath]
}
```

Если скомпилировать код и посмотреть на SIL представление, то можно заметить, что появился некоторый вызов `swift_getAtKeyPath` , который на самом деле и позволяет уже в рантайме извлечь нужное значение экземпляра `UserInfo` из произвольного источника `T`. Но прежде чем продолжать, давайте посмотрим что происходит в полученном коде:

```swift
  // %0 "source"                                    
  // %1 "keypath"                               
  %4 = function_ref @swift_getAtKeyPath // 1 
  %5 = alloc_stack $UserInfo // 2
  %6 = apply %4<T, UserInfo>(%5, %0, %1) // 3
  %7 = load %5 : $*UserInfo                        
  dealloc_stack %5 : $*UserInfo                    
  return %7 : $UserInfo // 4
```

1. По адресу `%4` помещается ссылка на символ `swift_getAtKeyPath`. 
2. На стеке текущего потока выделяется достаточное количество памяти для хранения локальной копии экземпляра `UserInfo`.
3. Происходит вызов метода `swift_getAtKeyPath`. На вход методу подаются три параметра: адрес стека по которому будет размещено значение `UserInfo`, ссылка по которой хранится объект (источник), а также ссылка на экземпляр `KeyPath` .
4. Возвращается извлеченный экземпляр `UserInfo`.

Реализация функции [getAtKeyPath](https://github.com/apple/swift/blob/main/stdlib/public/core/KeyPath.swift#L2024) является частью динамической библиотеки *libswiftcore*:

```swift
func getAtKeyPath<Root, Value>(
    root: Root,
    keyPath: KeyPath<Root, Value>
) -> Value {
    return keyPath._projectReadOnly(from: root)
}
```

В рамках метода идет обращение к переданному ранее экземпляру `KeyPath` , с последующим вызовом *internal* функции `_projectReadOnly` , которая на вход принимает ссылку на объект `Root` , а на выходе уже отдает искомое значение `Value` :

```swift
internal final func _projectReadOnly(from root: Root) -> Value {
    if let offset = getOffsetFromStorage() { 
        return withUnsafeBytes(of: root) {
          let pointer = $0.baseAddress.unsafelyUnwrapped.advanced(by: offset)
          return pointer.assumingMemoryBound(to: Value.self).pointee
        }
    }
    ...
}
```

В первую очередь происходит попытка получить некоторое смещение из экземпляра *keypath* с помощью вызова  `getOffsetFromStorage`. Если смещение удалось получить, то можно сразу вычислить адрес, по которому находится нужное значение `Value` - для этого только требуется к адресу объекта `root` прибавить смещение. 

Но остается важный вопрос - откуда именно берется нужное смещение, в какой момент оно вычисляется? В нашем случае с использованием простейших структур, смещение относительно начало объекта может быть [вычислено на этапе компиляции](https://github.com/apple/swift/blob/main/lib/IRGen/GenKeyPath.cpp#L662). Значение смещения помещается компилятором в специальную низкоуровневую структуру, которая называется паттерном (*key path pattern*). Паттерн используется для последующего создания экземпляра `KeyPath` рантайм библиотекой, которая впоследствии копирует значение смещения из паттерна и хранит его внутри самого *keypath*.

## Заключение

Сегодня мы взяли простейшие структуры и на их примере рассмотрели первые важные особенности `KeyPath`. Нам удалось понять, что в некоторых случаях компилятор способен эволюционировать код в прямое обращение к полю, как если бы мы вообще не использовали `KeyPath`. Если же не удалось достичь подобной оптимизация, то на этапе компиляции для требуемого объекта может быть вычислено смещение, с помощью которого уже в рантайме получится найти и извлечь значение нужного поля. При этом стоит отметить, что это смещение может быть вычислено на этапе компиляции не только для структур, но и для классов. 

Но всегда ли возможно вычислить нужное смещение на этапе компиляции? Это хороший вопрос, на который мы ответим в следующей статье, а также рассмотрим более сложные примеры использования `KeyPath`.