---
title: "По ту сторону полиморфизма. Часть 1: opaque type и дженерики."
layout: page
excerpt_separator: <!--more-->
---
Начал писать вторую статью по `KeyPath`, но в какой-то момент осознал, что она получается весьма сложной для ознакомления. Поэтому сперва предлагаю ознакомиться с текущей статьей, которая была написана еще осенью 2022.

Это первая часть цикла статей, посвященных различным аспектам полиморфизма в swift. Сегодня поговорим про `opaque type` и начнем изучение деталей реализации дженериков.
<!--more--> 

## Уровни абстракции

В первую очередь давайте определимся с тем, что такое `opaque type`. `Opaque type` - это любой метатип, конкретное значение которого не известно на этапе компиляции. Более того, раз конкретное значение подобного типа не может быть определено на этапе компиляции, значит и не может быть определено то, каким образом можно расположить экземпляры этого типа в памяти. Принято говорить, что экземпляры таких типов имеют `opaque layout`. Неспециализированные дженерики - хороший, но не единственный пример использования `opaque` типов. 

Концептуально, все типы в swift могут существовать на различных уровнях абстракции. Предположим, что у нас есть некоторое целочисленное значение, которое имеет конкретный тип `Int`. При передаче подобного значения в качестве аргумента функции, оно может помещаться напрямую в регистры процессора, без использования стека потока, или кучи. При этом то же самое значение может быть передано на вход дженерик-функции, принимающей значение некого неявного opaque типа `T`. Каким образом в данном случае должен выглядеть аргумент подобной функции, чтобы сохранить возможность передавать экземпляры любого типа? В случае со специализированными дженериками, на этапе компиляции может быть создано множество экземпляров описанной дженерик функции, входной параметр каждой из которых будет иметь конкретный тип. Но как быть в ситуации, когда специализация дженериков по ряду причин не может быть достигнута?

Продолжим пример с целочисленным значением. Для возможности передачи значения типа `Int` в подобную дженерик функцию, оно должно пройти процесс реабстракции. В подобном случае процесс реабстракции будет заключаться в предварительном размещение этого значения в некоторую адресуемую область памяти, с последующей передачей указателя на начало этой области памяти в качестве входного параметра. Реабстракция может носить более сложный характер, но принцип так или иначе один - значение должно быть помещено в уникальную адресуемую область памяти, указатель на которую дальше передается в качестве входного параметра. Получается, что с помощью `opaque type` может быть представлен любой тип. А перевод конкретно типа в opaque и обратно достигается засчет процесса реабстракции. Давайте теперь посмотрим на реабстракцию и дженерики детальнее.

## Неспециализированные дженерики и реабстракция

Начнем с рассмотрения неспециализированных дженериков, которые не ограничены протоколами. Чтобы посмотреть как именно происходит реабстракция и работают неспециализированные дженерики, я буду временами отключать все оптимизации компилятора и незначительно изменять символьное представление некоторых инструкций. Подобные преобразования помогут быстрее разобраться в сути происходящего. Рассмотрим простейший код:

```swift
func f<T>(_ f: T) -> T {
    let f = f
    return f
}

f(123)
```

Скомпилируем, начнем знакомиться с sil-версией кода. Начнем с main-функции, в рамках которой происходит вызов `f(123)` :

```swift
// main
sil @main : $@convention(c) (Int32, UnsafeMutablePointer<Optional<UnsafeMutablePointer<Int8>>>) -> Int32 {
bb0(%0 : $Int32, %1 : $UnsafeMutablePointer<Optional<UnsafeMutablePointer<Int8>>>):
  %2 = alloc_stack $Int                           // 1
  %3 = integer_literal $Builtin.Int64, 123        // 2
  %4 = struct $Int (%3 : $Builtin.Int64)          // 3
  %5 = alloc_stack $Int                           // 4
  store %4 to %5 : $*Int                          // 5
  // function_ref f<T>(_:)
  %7 = function_ref @$s4main1fyxxlF : $@convention(thin) <τ_0_0> (@in_guaranteed τ_0_0) -> @out τ_0_0 // 6
  %8 = apply %7<Int>(%2, %5) : $@convention(thin) <τ_0_0> (@in_guaranteed τ_0_0) -> @out τ_0_0 // 7
  dealloc_stack %5 : $*Int                        // 8
  dealloc_stack %2 : $*Int                        // 9
  ...
```

1. На стеке потока выделяется достаточное количество памяти для хранения значения типа `Int`.
2. Создается целочисленное литеральное значение `123` типа `Builtin.Int64`.
3. Создается зкземпляр структуры `Int`, который инициализируется значением, находящимся по адресу `%3`, т.е `123`.
4. На стеке еще раз выделяется достаточное количество памяти для хранения экземпляра типа `Int`.
5. Значение по адресу `%4` копируется в `%5`.
6. Создается ссылка на объявленный ранее метод `f<T>(_ f: T)` и помещается по адресу `%7`.
7. Происходит вызов функции по адресу `%7`, на вход подаются два значения: адрес `%2` и адрес `%5`, по которому мы ранее сохранили целочисленное значение `123`. Можно сразу заметить, что сигнатура объявленного в исходном коде метода явно изменилась при трансляции в sil. Видно, что на вход теперь подаются два параметра, а на выходе ничего не возвращается. Подобное преобразование - прямое следствия необходимой реабстракции, про которую мы говорили. Получается, что в качестве первого аргумента будет передаваться ссылка на область памяти, по которой можно записать результат выполнения дженерик функции. А в качестве второго аргумента - ссылка на область памяти, содержащую наш основной входной параметр.
8. После выполнения нашего метода, очищаем область памяти по адресу `%5`, которая была использована для временного хранения входного параметра.
9. Очищаем область памяти по адресу `%2`, которая была использована для хранения результата выполнения нашей функции.

Давайте теперь посмотрим на реализацию самого дженерик метода:

```swift
// f<T>(_:)
sil hidden @$s4main1fyxxlF : $@convention(thin) <T> (@in_guaranteed T) -> @out T {
// %0 "$return_value"                            
// %1 "f"                                         
bb0(%0 : $*T, %1 : $*T): // 1
  %3 = alloc_stack $T, let, name "f"              // 2
  copy_addr %1 to [initialization] %3 : $*T       // 3
  copy_addr %3 to [initialization] %0 : $*T       // 4
  destroy_addr %3 : $*T                           // 5
  dealloc_stack %3 : $*T                          // 6
  %8 = tuple ()                                   // 7
  return %8 : $()                                 
} // end sil function '$s4main1fyxxlF'
```

1. Как мы заметили ранее, сигнатура метода изменилась. В качестве первого аргумента `%0` передается ссылка на область памяти, по которой можно записать результат выполнения функции. А по адресу `%1` - ссылка на область памяти, содержащую наш основной входной параметр. Можно заметить, что входные параметры имеют тип `*T` , который называют типом адреса. Все значения подобного типа являются указателями на область памяти, в которой хранится либо конкретное значение типа `T` , либо ссылка на объект типа `T` .
2. На стеке выделяется необходимая память, для последующего хранения экземпляра типа `T`. Эта память потребуется для хранения локальной копии входного параметра.
3. Создается локальная копия входного параметра - копируется значение по адресу `%1` и помещается по адресу `%3`. 
4. Копируется значение по адресу `%3` и помещается по адресу `%0`. Т.е помещается необходимое значение по адресу, который был передан как адрес для записи результата выполнения данного метода.
5. Очищается значение, сохраненная по адресу `%3`.
6. Освобождается память, которая была выделена на стеке в пункте 2.
7. Создается пустой кортеж и после сразу возвращается.

У читателя может возникнуть вопрос, а зачем вообще создавать локальную копию, если напрямую можно записать необходимое значение по адресу `$0`. Действительно, в подобном коде компилятор способен применить подобную оптимизацию. Скомпилируем наш код еще раз, но уже с включенной оптимизацией:

```swift
// f<T>(_:)
sil hidden @$s4main1fyxxlF : $@convention(thin) <T> (@in_guaranteed T) -> @out T {
// %0 "$return_value"                             // user: %3
// %1 "f"                                         // users: %3, %2
bb0(%0 : $*T, %1 : $*T):
  copy_addr %1 to [initialization] %0 : $*T       // 1
  %4 = tuple ()                                   // user: %5
  return %4 : $()                                 // id: %5
} // end sil function '$s4main1fyxxlF'
```

Компилятор убрал значительную часть прежних инструкций. Теперь просто напрямую копируется значение по адресу `%1` и помещается по адресу `%0` , без создания локальной копии входного аргумента.
Сейчас весь полученный *sil* код выглядит относительно просто и понятно, однако все еще остается ряд нераскрытых вопросов. Как именно происходит копирование значения по одному адресу и последующее размещение его по другому адресу, каким образом определяется необходимое количество битов для копирование, ведь мы в рамках данного метода работаем с opaque type и на этапе компиляции не можем иметь представления о конкретном используемом типе. Для ответа на этот вопрос опустимся еще немного глубже.

## Лейаут метаданных и value witness table

Давайте теперь посмотрим на оптимизированную *LLVM IR* версию нашего метода:

```swift
// f<T>(_:)
define hidden swiftcc void @"$s4main1fyxxlF"(%swift.opaque* noalias nocapture sret(%swift.opaque) %0, %swift.opaque* noalias nocapture %1, %swift.type* %T) local_unnamed_addr #1 {
entry:
  %2 = getelementptr inbounds %swift.type, %swift.type* %T, i64 -1 // 1
  %3 = bitcast %swift.type* %2 to i8***
  %T.valueWitnesses = load i8**, i8*** %3, align 8, !invariant.load !20, !dereferenceable !21 // 2
  %4 = getelementptr inbounds i8*, i8** %T.valueWitnesses, i64 2
  %5 = bitcast i8** %4 to %swift.opaque* (%swift.opaque*, %swift.opaque*, %swift.type*)**
  %initializeWithCopy = load %swift.opaque* (%swift.opaque*, %swift.opaque*, %swift.type*)*, %swift.opaque* (%swift.opaque*, %swift.opaque*, %swift.type*)** %5, align 8, !invariant.load !20 // 3
  %7 = tail call %swift.opaque* %initializeWithCopy(%swift.opaque* noalias %0, %swift.opaque* noalias %1, %swift.type* %T) #2 // 4
  ret void
}
```

Я опишу основные и наиболее важные моменты полученного кода, опуская некоторые детали. Однако этого будет вполне достаточно, чтобы понять, что здесь происходит.

Обратим внимание на сигнатуру метода. Интересно, что она снова поменялась - теперь добавился третий параметр типа `swift.type*`, значение которого доступно по адресу `%T`. Этот параметр ничто иное, как указатель на соответствующий метатип изначального входного аргумента. Пройдемся по коду и выясним, для чего нам мог бы понадобиться метатип: 

1. В первую очередь вычисляем адрес памяти, находящийся со смещением -1 относительно указателя на метатип, и записываем результат по адресу `%2`. Важно отметить, что размер смещения напрямую зависит от архитектуры устройства. Для 64-битной архитектуры размер смещения будет равен 64 битам.
По полученному адресу памяти находится указатель на структуру, которую называют *value witness table* (далее *vwt*). *Value witness table* концептуально является классической координирующей таблицей (*vtable*), а обратившись к ней можно получить доступ к параметрам и операциям, позволяющим к примеру копировать, удалять экземпляры соответствующего типа. Для манипулирования экземплярами любого метатипа всегда существует соответствующая *vwt*, указатель которой гарантированно находится со смещением -1 относительно указателя на метатип.
Получается, что именно благодаря *vwt* мы можем взаимодействовать с экземплярами *opaque* типов на текущем уровне абстракции. Независимо от того, ссылка на какой метатип была передана в качестве входного аргумента нашей функции, мы всегда можем вычислить расположение соответствующей *vwt* и получить доступ к необходимым методам. Давайте дальше посмотрим к каким методам происходит обращение в рамках текущей реализации.
2. По ранее вычисленному адресу загружаем ссылку на *vwt*, помещая ее по адресу `%T.valueWitnesses` . 
3. Получив адрес на *vwt*, находим адрес метода `initializeWithCopy` и записываем по адресу `%initializeWithCopy`.
4. Обращаемся и вызываем метод  initializeWithCopy, на вход подаем уже известные нам параметры - `%0`, `%1`, `%T`. Результатом выполнения метода является копирование и последующая запись значения по адресу `%1` в адрес `%0`.

## Заключение
Сегодня мы рассмотрели уровни абстракции, на примере увидели, что одно и то же значение некоторого типа `T`, может в разные моменты времени существовать на разных уровнях абстракции. Для реализации неспециализированных дженериков конкретное значение подвергается процессу реабстракции, т.е попадает на более высокий уровень абстракции.
Для этого необходимое значение помещается в адресуемую область памяти и затем ссылка на эту область памяти, а также соответствующий указатель на метатип, передаются на вход дженерик методу. Далее для манипулирования *opaque* значением используется *vwt*. Каждый тип потенциально может иметь соответствующую ему реализацию *vwt*, однако некоторые типы вполне способны делить одну и ту же реализацию между собой.

В следующих статьях посмотрим другие интересные примеры неспециализированных дженериков, а также связанную с ними реабстракцию, которая может носить более сложный и ресурсозатратный характер.
